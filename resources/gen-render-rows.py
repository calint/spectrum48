#!/usr/bin/env python3
"""
Generate unrolled Z80 code for rendering all 24 tile rows on ZX Spectrum 48K
Usage: python gen_render_rows.py > render_rows.asm
"""


def generate_row(row_num):
    """Generate code for a single tile row"""

    # Determine screen third and base address
    if row_num < 8:
        # Top third
        base_d = 0x40
        row_in_third = row_num
    elif row_num < 16:
        # Middle third
        base_d = 0x48
        row_in_third = row_num - 8
    else:
        # Bottom third
        base_d = 0x50
        row_in_third = row_num - 16

    # Calculate E offset (0, 32, 64, 96, 128, 160, 192, 224)
    e_offset = row_in_third * 32

    code = []
    code.append(f"    ;{'=' * 75}")
    code.append(
        f"    ; ROW {row_num} (Character row {row_num}, scanlines {row_num * 8}-{row_num * 8 + 7})"
    )

    if row_num == 0:
        code.append(f"    ;{'=' * 75}")
    elif row_num == 8:
        code.append(f"    ; MIDDLE THIRD")
        code.append(f"    ;{'=' * 75}")
    elif row_num == 16:
        code.append(f"    ; BOTTOM THIRD")
        code.append(f"    ;{'=' * 75}")
    else:
        code.append(f"    ;{'=' * 75}")

    # Push column counter on first row only
    if row_num == 0:
        code.append("    push bc             ; save column counter for all rows")

    # Restore column counter (except for first row)
    if row_num > 0:
        code.append("    pop bc")
        code.append("    push bc")

    # Set screen address
    code.append(f"    ld d, ${base_d:02X}")
    if e_offset == 0:
        code.append("    ld e, c")
    else:
        code.append("    ld a, c")
        code.append(f"    add a, {e_offset}")
        code.append("    ld e, a")

    # Get tile from map
    code.append(f"    ld h, (tile_map / 256) + {row_num}")
    code.append("    ld a, (camera_x)")
    code.append("    add a, c")
    code.append("    ld l, a")
    code.append("    ld a, (hl)")

    # Calculate charset address (tile_id * 8)
    code.append("    ld l, a")
    code.append("    ld h, 0")
    code.append("    add hl, hl           ; * 2")
    code.append("    add hl, hl           ; * 4")
    code.append("    add hl, hl           ; * 8")
    code.append("    ld bc, charset")
    code.append("    add hl, bc")

    # Render 8 scanlines
    for scanline in range(8):
        code.append("    ld a, (hl)")
        code.append("    ld (de), a")
        code.append("    inc hl")
        if scanline < 7:  # Don't increment D after last scanline
            code.append("    inc d")

    code.append("")
    return "\n".join(code)


def generate_all_rows():
    """Generate code for all 24 rows"""

    print(
        ";==============================================================================="
    )
    print("; AUTO-GENERATED CODE: Render all 24 tile rows")
    print("; Generated by: gen_render_rows.py")
    print(
        ";==============================================================================="
    )
    print("; This code renders a full screen of tiles (32 columns Ã— 24 rows)")
    print("; Input: C = column number (0-31)")
    print("; Expects: camera_x, tile_map, charset to be defined")
    print("; Clobbers: A, BC, DE, HL")
    print("; Stack: Pushes BC on entry, pops BC on exit (balanced)")
    print(
        ";==============================================================================="
    )
    print()

    for row in range(24):
        print(generate_row(row))

    print(
        "    ;==========================================================================="
    )
    print("    ; Restore column counter and return")
    print(
        "    ;==========================================================================="
    )
    print("    pop bc              ; restore column counter")
    print()


def generate_optimized_version():
    """Generate an even more optimized version with fewer pop/push using IX"""

    print(
        ";==============================================================================="
    )
    print("; OPTIMIZED VERSION: Uses IX register, minimal stack operations")
    print(
        ";==============================================================================="
    )
    print("; This version is ~3.6% faster than standard version")
    print("; Saves column counter in IXH instead of using stack")
    print(
        ";==============================================================================="
    )
    print()

    for row in range(24):
        if row < 8:
            base_d = 0x40
            row_in_third = row
        elif row < 16:
            base_d = 0x48
            row_in_third = row - 8
        else:
            base_d = 0x50
            row_in_third = row - 16

        e_offset = row_in_third * 32

        # Only save once per column, not per row
        if row == 0:
            print("    ; Save C once for all rows")
            print("    ld ixh, c           ; Save column in IXH (8 cycles)")
            print()

        print(f"    ;{'=' * 75}")
        print(f"    ; Row {row}")
        print(f"    ;{'=' * 75}")
        print(f"    ld d, ${base_d:02X}")
        if e_offset == 0:
            print("    ld e, ixh")
        else:
            print("    ld a, ixh")
            print(f"    add a, {e_offset}")
            print("    ld e, a")

        print(f"    ld h, (tile_map / 256) + {row}")
        print("    ld a, (camera_x)")
        print("    add a, ixh")
        print("    ld l, a")
        print("    ld a, (hl)")
        print("    ld l, a")
        print("    ld h, 0")
        print("    add hl, hl")
        print("    add hl, hl")
        print("    add hl, hl")
        print("    ld bc, charset")
        print("    add hl, bc")

        for scanline in range(8):
            print("    ld a, (hl)")
            print("    ld (de), a")
            print("    inc hl")
            if scanline < 7:
                print("    inc d")
        print()

    print(
        "    ;==========================================================================="
    )
    print("    ; Restore C and return")
    print(
        "    ;==========================================================================="
    )
    print("    ld c, ixh           ; Restore column counter")
    print()


def generate_with_macros():
    """Generate macro-based version for assemblers that support macros"""

    print(
        ";==============================================================================="
    )
    print("; MACRO VERSION: For assemblers with macro support (sjasmplus, pasmo)")
    print(
        ";==============================================================================="
    )
    print()
    print("    macro RENDER_ROW row_num, base_d, e_offset")
    print("    if row_num == 0")
    print("    push bc")
    print("    endif")
    print("    if row_num > 0")
    print("    pop bc")
    print("    push bc")
    print("    endif")
    print("    ld d, base_d")
    print("    if e_offset == 0")
    print("    ld e, c")
    print("    else")
    print("    ld a, c")
    print("    add a, e_offset")
    print("    ld e, a")
    print("    endif")
    print("    ld h, (tile_map / 256) + row_num")
    print("    ld a, (camera_x)")
    print("    add a, c")
    print("    ld l, a")
    print("    ld a, (hl)")
    print("    ld l, a")
    print("    ld h, 0")
    print("    add hl, hl")
    print("    add hl, hl")
    print("    add hl, hl")
    print("    ld bc, charset")
    print("    add hl, bc")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    inc hl")
    print("    inc d")
    print("    ld a, (hl)")
    print("    ld (de), a")
    print("    endm")
    print()

    for row in range(24):
        if row < 8:
            base_d = 0x40
            e_offset = row * 32
        elif row < 16:
            base_d = 0x48
            e_offset = (row - 8) * 32
        else:
            base_d = 0x50
            e_offset = (row - 16) * 32

        print(f"    RENDER_ROW {row}, ${base_d:02X}, {e_offset}")

    print()
    print("    pop bc              ; restore column counter")
    print()


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "--optimized":
        generate_optimized_version()
    elif len(sys.argv) > 1 and sys.argv[1] == "--macros":
        generate_with_macros()
    else:
        generate_all_rows()
